# 3.9.1 Short Answer

---

## 1. 세 가지 서로 다른 명령어 니모닉 예시를 제시하시오.  
**답:** `MOV`, `ADD`, `SUB`

---

## 2. 호출 규약(Calling Convention)이란 무엇이며, 어셈블리 언어 선언에서 어떻게 사용되는가?  
**답:** 호출 규약은 함수가 매개변수를 전달하고 반환값을 주고받는 방식을 정의한다.  
(예: 레지스터를 사용할지, 스택을 사용할지 등)  
이를 통해 호출자와 피호출자가 일관되게 상호작용할 수 있다.

---

## 3. 프로그램에서 스택 공간을 어떻게 예약하는가?  
**답:**  
- 스택 포인터(`ESP` 또는 `RSP`)를 조정  
- `.STACK` 지시어 사용  
- `SUB ESP, n` 명령으로 공간 확보  

---

## 4. *assembler language*라는 용어가 정확하지 않은 이유는 무엇인가?  
**답:** "Assembler"는 어셈블리 코드를 기계어로 번역하는 **도구**이고,  
언어 자체는 **assembly language(어셈블리 언어)** 가 정확한 표현이다.

---

## 5. 빅 엔디안(Big Endian)과 리틀 엔디안(Little Endian)의 차이를 설명하고, 용어의 기원을 설명하시오.  
**답:**  
- **빅 엔디안:** 가장 중요한 바이트(MSB)를 낮은 주소에 저장  
- **리틀 엔디안:** 가장 덜 중요한 바이트(LSB)를 낮은 주소에 저장  
- **기원:** 조너선 스위프트의 소설 *걸리버 여행기*에서, 달걀을 큰 쪽 끝(Big end)부터 깰지 작은 쪽 끝(Little end)부터 깰지를 두고 다투던 풍자에서 유래

---

## 6. 정수 리터럴 대신 기호 상수(Symbolic Constant)를 사용하는 이유는 무엇인가?  
**답:** 코드의 **가독성**과 **유지보수성**을 높이며, 값 변경 시 한 곳만 수정하면 되므로 오류를 줄일 수 있다.

---

## 7. 소스 파일(Source File)과 리스팅 파일(Listing File)의 차이를 설명하시오.  
**답:**  
- 소스 파일: 원래 작성한 어셈블리 코드  
- 리스팅 파일: 어셈블러가 생성한 파일로, 소스 코드 + 기계어 + 주소 정보를 포함  

---

## 8. 데이터 라벨(Data Label)과 코드 라벨(Code Label)의 차이를 설명하시오.  
**답:**  
- 데이터 라벨: 변수가 저장된 메모리 위치를 지칭  
- 코드 라벨: 특정 명령어 위치를 지칭 (분기/점프/호출 시 사용)  

---

## 9. (참/거짓) 식별자는 숫자로 시작할 수 없다.  
**답:** 참(True)

---

## 10. (참/거짓) 16진수 리터럴은 `0x3A`와 같이 표현할 수 있다.  
**답:** 참(True)

---

## 11. (참/거짓) 어셈블리 언어 지시어는 실행 시간에 실행된다.  
**답:** 거짓(False) – 지시어는 실행 시간이 아니라 어셈블 과정에서 처리된다.

---

## 12. (참/거짓) 어셈블리 언어 지시어는 대문자와 소문자를 자유롭게 섞어서 쓸 수 있다.  
**답:** 참(True)

---

## 13. 어셈블리 언어 명령문의 네 가지 기본 요소를 쓰시오.  
**답:**  
1. 라벨 (선택 사항)  
2. 명령어 니모닉  
3. 피연산자  
4. 주석 (선택 사항)  

---

## 14. (참/거짓) `MOV`는 명령어 니모닉의 예이다.  
**답:** 참(True)

---

## 15. (참/거짓) 코드 라벨은 콜론(`:`)으로 끝나지만, 데이터 라벨은 콜론으로 끝나지 않는다.  
**답:** 참(True)

---

## 16. 블록 주석의 예시를 작성하시오.  
**답:**  
```asm
COMMENT !
여러 줄로 작성 가능한
블록 주석 예시
!
```
---

## 17. 변수를 접근할 때 숫자 주소를 사용하는 것이 좋지 않은 이유는 무엇인가?

**답:** 숫자 주소를 직접 사용하면 코드가 **읽기 어렵고 유지보수가 힘들다**.
라벨을 사용하면 메모리 위치가 바뀌어도 자동으로 반영된다.

---

## 18. `ExitProcess` 프로시저에 전달해야 하는 인자의 유형은 무엇인가?

**답:** 정수(Integer, 종료 코드)

---

## 19. 어떤 지시어가 프로시저를 끝내는가?

**답:** `ENDP`

---

## 20. 32비트 모드에서 `END` 지시어의 식별자는 어떤 목적을 가지는가?

**답:** 프로그램의 **시작 지점(entry point)** 라벨을 지정한다.

---

## 21. `PROTO` 지시어의 목적은 무엇인가?

**답:** 프로시저의 원형(Prototype)을 선언하여, 정의 전에 호출할 수 있도록 한다.

---

## 22. (참/거짓) 오브젝트 파일은 링커(Linker)가 생성한다.

**답:** 거짓(False) – 어셈블러가 오브젝트 파일을 생성한다.

---

## 23. (참/거짓) 리스팅 파일은 어셈블러가 생성한다.

**답:** 참(True)

---

## 24. (참/거짓) 실행 파일을 만들기 직전에 링크 라이브러리가 프로그램에 추가된다.

**답:** 참(True)

---

## 25. 어떤 데이터 지시어가 32비트 부호 있는 정수 변수를 생성하는가?

**답:** `SDWORD`

---

## 26. 어떤 데이터 지시어가 16비트 부호 있는 정수 변수를 생성하는가?

**답:** `SWORD`

---

## 27. 어떤 데이터 지시어가 64비트 부호 없는 정수 변수를 생성하는가?

**답:** `QWORD`

---

## 28. 어떤 데이터 지시어가 8비트 부호 있는 정수 변수를 생성하는가?

**답:** `SBYTE`

---

## 29. 어떤 데이터 지시어가 10바이트 패킹된 BCD 변수를 생성하는가?

**답:** `TBYTE`



