# 7.9.1 Short Answer

## 1. Shift and Rotate Operations on 0D4h

**Question:** In the following code sequence, show the value of AL after each shift or rotate instruction has executed:

```assembly
mov al,0D4h
shr al,1        ; a.
mov al,0D4h
sar al,1        ; b.
mov al,0D4h
sar al,4        ; c.
mov al,0D4h
rol al,1        ; d.
```

**Answer:**

a. `shr al,1` → **AL = 6Ah**
   - 0D4h = 11010100b
   - 논리적 우측 시프트 1비트: 01101010b = 6Ah

b. `sar al,1` → **AL = EAh**
   - 0D4h = 11010100b
   - 산술 우측 시프트 1비트 (부호 비트 유지): 11101010b = EAh

c. `sar al,4` → **AL = FDh**
   - 0D4h = 11010100b
   - 산술 우측 시프트 4비트: 11111101b = FDh

d. `rol al,1` → **AL = A9h**
   - 0D4h = 11010100b
   - 좌측 회전 1비트: 10101001b = A9h

---

## 2. More Shift and Rotate Operations on 0D4h

**Question:** In the following code sequence, show the value of AL after each shift or rotate instruction has executed:

```assembly
mov al,0D4h
ror al,3        ; a.
mov al,0D4h
rol al,7        ; b.
stc
mov al,0D4h
rcl al,1        ; c.
stc
mov al,0D4h
rcr al,3        ; d.
```

**Answer:**

a. `ror al,3` → **AL = A9h**
   - 0D4h = 11010100b
   - 우측 회전 3비트: 10101001b = A9h

b. `rol al,7` → **AL = 6Ah**
   - 0D4h = 11010100b
   - 좌측 회전 7비트: 01101010b = 6Ah

c. `stc; rcl al,1` → **AL = A9h**
   - Carry 플래그 = 1
   - 0D4h = 11010100b
   - Carry 포함 좌측 회전: 10101001b = A9h
   - 새로운 CF = 1

d. `stc; rcr al,3` → **AL = BAh**
   - Carry 플래그 = 1
   - 0D4h = 11010100b
   - Carry 포함 우측 회전 3비트: 10111010b = BAh

---

## 3. MUL Operation

**Question:** What will be the contents of AX and DX after the following operation?

```assembly
mov dx,0
mov ax,222h
mov cx,100h
mul cx
```

**Answer:**

**AX = 2200h, DX = 0002h**

- 222h × 100h = 22200h
- 상위 16비트(DX) = 0002h
- 하위 16비트(AX) = 2200h

---

## 4. DIV Operation (8-bit)

**Question:** What will be the contents of AX after the following operation?

```assembly
mov ax,63h
mov bl,10h
div bl
```

**Answer:**

**AX = 0306h**

- 피제수: 63h (99 decimal)
- 제수: 10h (16 decimal)
- 몫(AL) = 06h
- 나머지(AH) = 03h
- AX = 0306h

---

## 5. DIV Operation (32-bit)

**Question:** What will be the contents of EAX and EDX after the following operation?

```assembly
mov eax,123400h
mov edx,0
mov ebx,10h
div ebx
```

**Answer:**

**EAX = 00012340h, EDX = 0**

- 피제수: 123400h
- 제수: 10h
- 몫(EAX) = 12340h
- 나머지(EDX) = 0

---

## 6. DIV Operation (16-bit)

**Question:** What will be the contents of AX and DX after the following operation?

```assembly
mov ax,4000h
mov dx,500h
mov bx,10h
div bx
```

**Answer:**

**AX = 3400h, DX = 0**

- 피제수: DX:AX = 500_4000h
- 제수: 10h
- 몫(AX) = 3400h
- 나머지(DX) = 0

---

## 7. ADC Operation

**Question:** What will be the contents of BX after the following instructions execute?

```assembly
mov bx,5
stc
mov ax,60h
adc bx,ax
```

**Answer:**

**BX = 0066h**

- BX = 5
- Carry 플래그 = 1 (stc)
- AX = 60h
- BX = BX + AX + CF = 5 + 60h + 1 = 66h

---

## 8. 64-bit Division Output

**Question:** Describe the output when the following code executes in 64-bit mode:

```assembly
.data
dividend_hi QWORD 00000108h
dividend_lo QWORD 33300020h
divisor QWORD 00000100h
.code
mov rdx,dividend_hi
mov rax,dividend_lo
div divisor
```

**Answer:**

**RAX = 0000000108333000h, RDX = 0000000000000020h**

- 피제수: RDX:RAX = 0000010833300020h
- 제수: 100h
- 몫(RAX) = 108333000h
- 나머지(RDX) = 20h

---

## 9. Correcting QWORD Subtraction Code

**Question:** The following program is supposed to subtract val2 from val1. Find and correct all logic errors:

```assembly
.data
val1 QWORD 20403004362047A1h
val2 QWORD 055210304A2630B2h
result QWORD 0
.code
mov cx,8
mov esi,val1
mov edi,val2
clc
top:
    mov al,BYTE PTR[esi]
    sbb al,BYTE PTR[edi]
    mov BYTE PTR[esi],al
    dec esi
    dec edi
    loop top
```

**Answer:**

**오류 및 수정사항:**

1. **인덱스 방향 오류**: 최하위 바이트부터 시작해야 함
2. **결과 저장 위치 오류**: result에 저장해야 함
3. **인덱스 증가 오류**: dec 대신 inc 사용

**수정된 코드:**

```assembly
.data
val1 QWORD 20403004362047A1h
val2 QWORD 055210304A2630B2h
result QWORD 0
.code
mov cx,8
mov esi,0              ; 인덱스를 0부터 시작
mov edi,OFFSET result  ; result에 저장
clc
top:
    mov al,BYTE PTR val1[esi]
    sbb al,BYTE PTR val2[esi]
    mov BYTE PTR[edi],al
    inc esi               ; 증가로 변경
    inc edi               ; 증가로 변경
    loop top
```

---

## 10. 64-bit IMUL Operation

**Question:** What will be the hexadecimal contents of RAX after the following instructions execute in 64-bit mode?

```assembly
.data
multiplicand QWORD 0001020304050000h
.code
imul rax,multiplicand,4
```

**Answer:**

**RAX = 0004080C10140000h**

- 0001020304050000h × 4 = 0004080C10140000h
- 각 바이트가 4배가 됨:
  - 00 × 4 = 00
  - 05 × 4 = 14
  - 04 × 4 = 10
  - 03 × 4 = 0C
  - 02 × 4 = 08
  - 01 × 4 = 04
 
