# 5.8.1 Short Answer

---

**1. Which instruction pushes all of the 32-bit general-purpose registers on the stack?**
정답: `PUSHAD` (32비트 범용 레지스터 전부를 정해진 순서로 스택에 푸시합니다)

---

**2. Which instruction pushes the 32-bit EFLAGS register on the stack?**
정답: `PUSHFD` (32비트 EFLAGS를 스택에 푸시)

---

**3. Which instruction pops the stack into the EFLAGS register?**
정답: `POPFD` (스택의 값을 32비트 EFLAGS로 팝)

---

**4. Challenge: Another assembler (called NASM) permits the PUSH instruction to list multiple
specific registers. Why might this approach be better than the PUSHAD instruction in
MASM? Here is a NASM example:
PUSH EAX EBX ECX**
정답: 필요한 레지스터만 선택적으로 저장하므로

* **스택 사용량**이 줄고,
* **실행시간**이 단축되며,
* `PUSHAD`처럼 불필요한 레지스터(심지어 이전 ESP 값까지)까지 저장하지 않아 **부작용/복잡도**가 줄어듭니다. 또한 저장 **순서를 제어**할 수 있습니다.

---

**5. Challenge: Suppose there were no PUSH instruction. Write a sequence of two other instruc
tions that would accomplish the same as push eax.**
정답:

```asm
SUB  ESP, 4
MOV  [ESP], EAX
```

(스택 공간을 4바이트 확보한 뒤 그 위치에 EAX를 저장)

---

**6. (True/False): The RET instruction pops the top of the stack into the instruction pointer.**
정답: **True**. (`RET`는 스택 최상단의 반환 주소를 `EIP`로 팝하여 분기)

---

**7. (True/False): Nested procedure calls are not permitted by the Microsoft assembler unless
the NESTED operator is used in the procedure definition.**
정답: **False**. 중첩 호출은 기본적으로 허용되며, 특정 지시어가 없어도 호출 가능합니다.

---

**8. (True/False): In protected mode, each procedure call uses a minimum of 4 bytes of stack
space.**
정답: **True**. 32비트 보호 모드에서 `CALL`은 최소 **4바이트 반환 주소**를 스택에 푸시합니다.

---

**9. (True/False): The ESI and EDI registers cannot be used when passing 32-bit parameters to
procedures.**
정답: **False**. ESI/EDI도 일반 레지스터처럼 **매개변수 전달**에 사용할 수 있습니다.

---

**10. (True/False): The ArraySum procedure (Section 5.2.5) receives a pointer to any array of
doublewords.**
정답: **True**. 해당 프로시저는 **더블워드(DWORD) 배열 포인터**를 인자로 받습니다.

---

**11. (True/False): The USES operator lets you name all registers that are modified within a pro
cedure.**
정답: **True**. `USES`에 나열한 레지스터는 프로시저 진입/탈출 시 **자동으로 보존**(push/pop 생성)됩니다. 보통 “이 프로시저에서 변경하는 레지스터들”을 적습니다.

---

**12. (True/False): The USES operator only generates PUSH instructions, so you must code POP
instructions yourself.**
정답: **False**. `USES`는 **진입 시 PUSH, 종료 시 POP**까지 자동 생성합니다.

---

**13. (True/False): The register list in the USES directive must use commas to separate the regis
ter names.**
정답: **False**. `USES eax ebx ecx`처럼 **공백**으로 구분합니다(쉼표가 아님).

---

**14. Which statement(s) in the ArraySum procedure (Section 5.2.5) would have to be modified so
it could accumulate an array of 16-bit words? Create such a version of ArraySum and test it.**
정답: **데이터 크기와 인덱스 증가폭**을 16비트에 맞춰 수정해야 합니다. 즉,

* 요소 로드 시 `WORD PTR` 사용 + 32비트 합산을 위해 `MOVZX`(또는 `XOR EDX,EDX` 후 `MOV DX, [..]`) 사용,
* 포인터 증가폭을 `+2`로 변경.
  예시( MASM / Irvine 스타일 시그니처 ):

```asm
; ArraySum16: 16비트 WORD 배열 합계를 32비트 EAX로 반환
; proto: ArraySum16 PROTO pArray:PTR WORD, count:DWORD
ArraySum16 PROC USES esi ecx edx, pArray:PTR WORD, count:DWORD
    mov     esi, pArray
    mov     ecx, count
    xor     eax, eax            ; 누적합 = 0

@@loop:
    test    ecx, ecx
    jz      @@done
    movzx   edx, WORD PTR [esi] ; 16비트 로드 후 32비트로 zero-extend
    add     eax, edx
    add     esi, 2              ; 다음 WORD
    dec     ecx
    jmp     @@loop

@@done:
    ret
ArraySum16 ENDP
```

---

**15. What will be the final value in EAX after these instructions execute?
push 5
push 6
pop  eax
pop  eax**
정답: **5**. (첫 `POP`으로 EAX=6, 두 번째 `POP`으로 EAX=5로 덮어씀)

---

**16. Which statement is true about what will happen when the example code runs?**

```
1: main PROC
2: 
push 10
3:
4:
5:
6:
push 20
call Ex2Sub
pop  eax
INVOKE ExitProcess,0
7: main ENDP
8:
9: Ex2Sub PROC
10:
pop eax
11:
ret
12: Ex2Sub ENDP
```

a. EAX will equal 10 on line 6
b. The program will halt with a runtime error on Line 10
c. EAX will equal 20 on line 6
d. The program will halt with a runtime error on Line 11

정답: **d**. `call`이 푸시한 **반환 주소**가 스택 최상단인데, `Ex2Sub`에서 `pop eax`가 이를 꺼내 버려 `ret`가 잘못된 주소(다음 값 20)를 팝하여 **실행 오류**가 발생합니다.

---

**17. Which statement is true about what will happen when the example code runs?**

```
1: main PROC
2:
mov  eax,30
3:
4:
5:
6:
push eax
push 40
call Ex3Sub
INVOKE ExitProcess,0
7: main ENDP
8:
9: Ex3Sub PROC
10:
pusha
11:
12:
mov eax,80
popa
13:
ret
14: Ex3Sub ENDP
```

a. EAX will equal 40 on line 6
b. The program will halt with a runtime error on Line 6
c. EAX will equal 30 on line 6
d. The program will halt with a runtime error on Line 13

정답: **c**. `pusha/popa`로 `Ex3Sub` 내에서 EAX를 80으로 바꿔도 반환 시 **원래 값(30)**이 복원됩니다. 따라서 라인 6 시점(푸시 전후)에서도 EAX는 30입니다.

---

**18. Which statement is true about what will happen when the example code runs?**

```
1: main PROC
2:
mov eax,40
3:
4:
push offset Here
jmp  Ex4Sub
5:    Here:
6:
mov eax,30
7:
INVOKE ExitProcess,0
8: main ENDP
9:
10: Ex4Sub PROC
11:
ret
12: Ex4Sub ENDP
```

a. EAX will equal 30 on line 7
b. The program will halt with a runtime error on Line 4
c. EAX will equal 30 on line 6
d. The program will halt with a runtime error on Line 11

정답: **a**. `push offset Here` 후 `jmp Ex4Sub` → `ret`가 `Here`로 복귀 → 라인 6에서 `mov eax,30` 실행 → 라인 7 시점에 EAX=30.

---

**19. Which statement is true about what will happen when the example code runs?**

```
1: main PROC
2:
mov edx,0
3:
4:
5:
6:
mov eax,40
push eax
call Ex5Sub
INVOKE ExitProcess,0
7: main ENDP
8:
9: Ex5Sub PROC
10:
pop  eax
11:
12:
13:
pop  edx
push eax
ret
14: Ex5Sub ENDP
```

a. EDX will equal 40 on line 6
b. The program will halt with a runtime error on Line 13
c. EDX will equal 0 on line 6
d. The program will halt with a runtime error on Line 11

정답: **a**. `Ex5Sub`에서 첫 `pop eax`가 **반환 주소**를 꺼내고, 다음 `pop edx`가 **40**을 꺼냅니다. 이어서 `push eax`로 반환 주소를 복구한 뒤 `ret`으로 정상 복귀하므로, 복귀 후 EDX=40이 됩니다.

---

**20. What values will be written to the array when the following code executes?**

```
.data
array DWORD 4 DUP(0)
.code
main PROC
 mov eax,10
 mov  esi,0
 call proc_1
 add  esi,4
 add  eax,10
 mov  array[esi],eax
 INVOKE ExitProcess,0
main ENDP

proc_1 PROC
 call proc_2
 add  esi,4
 add  eax,10
 mov  array[esi],eax
 ret
proc_1 ENDP

proc_2 PROC
 call proc_3
 add  esi,4
 add  eax,10
 mov  array[esi],eax
 ret
proc_2 ENDP

proc_3 PROC
 mov  array[esi],eax
 ret
proc_3 ENDP
```

정답: **`array = {10, 20, 30, 40}`**

* `proc_3`: `array[0] = 10`
* `proc_2` 복귀 후: `ESI+=4, EAX+=10` → `array[1] = 20`
* `proc_1` 복귀 후: `ESI+=4, EAX+=10` → `array[2] = 30`
* `main` 복귀 후: `ESI+=4, EAX+=10` → `array[3] = 40`

