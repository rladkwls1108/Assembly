# 4.9 Review Questions and Exercises - Solutions

## 4.9.1 Short Answer

### 1. MOVSX with WORD values
**Question:** What will be the value in EDX after each of the lines marked (a) and (b) execute?
```asm
.data
one WORD 8002h
two WORD 4321h
.code
mov edx,21348041h
movsx edx,one  ; (a)
movsx edx,two  ; (b)
```

**Answer:**
- **(a)** EDX = FFFF8002h (sign-extended from 8002h, MSB=1 so negative)
- **(b)** EDX = 00004321h (sign-extended from 4321h, MSB=0 so positive)

---

### 2. INC operation on AX
**Question:** What will be the value in EAX after the following lines execute?
```asm
mov eax,1002FFFFh
inc ax
```

**Answer:**
- EAX = 10020000h
- Explanation: AX = FFFFh, after INC: AX = 0000h, upper word (1002h) unchanged

---

### 3. DEC operation on AX
**Question:** What will be the value in EAX after the following lines execute?
```asm
mov eax,30020000h
dec ax
```

**Answer:**
- EAX = 3002FFFFh
- Explanation: AX = 0000h, after DEC: AX = FFFFh, upper word (3002h) unchanged

---

### 4. NEG operation on AX
**Question:** What will be the value in EAX after the following lines execute?
```asm
mov eax,1002FFFFh
neg ax
```

**Answer:**
- EAX = 10020001h
- Explanation: AX = FFFFh, NEG(FFFFh) = 0001h, upper word unchanged

---

### 5. Parity flag after ADD
**Question:** What will be the value of the Parity flag after the following lines execute?
```asm
mov al,1
add al,3
```

**Answer:**
- Parity Flag = 0 (odd parity)
- Explanation: AL = 1 + 3 = 4 = 00000100b (one 1-bit = odd parity, PF=0)

---

### 6. Sign flag after SUB
**Question:** What will be the value of EAX and the Sign flag after the following lines execute?
```asm
mov eax,5
sub eax,6
```

**Answer:**
- EAX = FFFFFFFFh (-1 in two's complement)
- Sign Flag = 1 (MSB is 1, indicating negative result)

---

### 7. Overflow flag analysis
**Question:** In the following code, the value in AL is intended to be a signed byte. Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range.
```asm
mov al,-1
add al,130
```

**Answer:**
- AL = -1 (FFh) + 130 (82h) = 129 (81h)
- The Overflow flag WILL be set to 1
- Explanation: Adding two negative numbers (in signed interpretation: -1 + -126 = -127) produces what appears to be a negative result (81h = -127). However, mathematically -1 + 130 = 129, which exceeds the signed byte range of -128 to +127. The OF=1 indicates the result is invalid for signed arithmetic, helping detect the overflow.

---

### 8. 64-bit MOV immediate
**Question:** What value will RAX contain after the following instruction executes?
```asm
mov rax,44445555h
```

**Answer:**
- RAX = 0000000044445555h
- Explanation: Upper 32 bits are zero-extended

---

### 9. MOV DWORD to RAX
**Question:** What value will RAX contain after the following instructions execute?
```asm
.data
dwordVal DWORD 84326732h
.code
mov rax,0FFFFFFFF00000000h
mov rax,dwordVal
```

**Answer:**
- RAX = 0000000084326732h
- Explanation: Moving a DWORD to RAX zero-extends the upper 32 bits

---

### 10. WORD PTR modification
**Question:** What value will EAX contain after the following instructions execute?
```asm
.data
dVal DWORD 12345678h
.code
mov ax,3
mov WORD PTR dVal+2,ax
mov eax,dVal
```

**Answer:**
- EAX = 00035678h
- Explanation: dVal initially = 12345678h (bytes: 78 56 34 12), high word (bytes 2-3) changed to 0003h, result = 00035678h

---

### 11. Complex WORD PTR operations
**Question:** What will EAX contain after the following instructions execute?
```asm
.data
dVal DWORD ?
.code
mov dVal,12345678h
mov ax,WORD PTR dVal+2
add ax,3
mov WORD PTR dVal,ax
mov eax,dVal
```

**Answer:**
- EAX = 12341237h
- Explanation: 
  - dVal = 12345678h
  - AX = high word = 1234h
  - AX = 1234h + 3 = 1237h
  - Low word of dVal = 1237h
  - Result = 12341237h

---

### 12. Overflow with positive + negative
**Question:** (Yes/No): Is it possible to set the Overflow flag if you add a positive integer to a negative integer?

**Answer:**
- **No**
- Explanation: Overflow occurs only when adding two positive numbers yields a negative result, or adding two negative numbers yields a positive result. Adding positive and negative numbers cannot cause signed overflow.

---

### 13. Overflow with negative + negative
**Question:** (Yes/No): Will the Overflow flag be set if you add a negative integer to a negative integer and produce a positive result?

**Answer:**
- **Yes**
- Explanation: When adding two negative numbers produces a positive result, it indicates signed overflow (result exceeded the negative range).

---

### 14. NEG instruction overflow
**Question:** (Yes/No): Is it possible for the NEG instruction to set the Overflow flag?

**Answer:**
- **Yes**
- Explanation: NEG 80h (in 8-bit) or NEG 8000h (in 16-bit) sets the Overflow flag because the most negative value has no positive counterpart in two's complement.

---

### 15. Sign and Zero flags together
**Question:** (Yes/No): Is it possible for both the Sign and Zero flags to be set at the same time?

**Answer:**
- **No**
- Explanation: Zero flag is set when result = 0 (all bits are 0, including MSB). Sign flag is set when MSB = 1. These conditions are mutually exclusive.

---

## Variable Definitions for Questions 16-19
```asm
.data
var1 SBYTE -4,-2,3,1
var2 WORD 1000h,2000h,3000h,4000h
var3 SWORD -16,-42
var4 DWORD 1,2,3,4,5
```

### 16. Instruction validity
**Question:** For each of the following statements, state whether or not the instruction is valid:

**Answer:**
- a. `mov ax,var1` - **Invalid** (size mismatch: AX is 16-bit, var1 is 8-bit)
- b. `mov ax,var2` - **Valid**
- c. `mov eax,var3` - **Invalid** (size mismatch: EAX is 32-bit, var3 is 16-bit)
- d. `mov var2,var3` - **Invalid** (cannot move memory to memory)
- e. `movzx ax,var2` - **Invalid** (destination must be larger than source)
- f. `movzx var2,al` - **Invalid** (destination must be register)
- g. `mov ds,ax` - **Valid**
- h. `mov ds,1000h` - **Invalid** (cannot move immediate to segment register directly)

---

### 17. Operations with var1
**Question:** What will be the hexadecimal value of the destination operand after each of the following instructions execute in sequence?
```asm
mov al,var1      ; a.
mov ah,[var1+3]  ; b.
```

**Answer:**
- **(a)** AL = FCh (var1[0] = -4 in two's complement)
- **(b)** AH = 01h (var1[3] = 1), so AX = 01FCh

---

### 18. Operations with var2 and var3
**Question:** What will be the value of the destination operand after each of the following instructions execute in sequence?
```asm
mov ax,var2      ; a.
mov ax,[var2+4]  ; b.
mov ax,var3      ; c.
mov ax,[var3-2]  ; d.
```

**Answer:**
- **(a)** AX = 1000h
- **(b)** AX = 3000h (var2[2], offset +4 bytes)
- **(c)** AX = FFF0h (-16 in two's complement)
- **(d)** AX = 4000h (accesses 2 bytes before var3, which is the last element of var2)

---

### 19. Operations with var4, var2, and var1
**Question:** What will be the value of the destination operand after each of the following instructions execute in sequence?
```asm
mov edx,var4       ; a.
movzx edx,var2     ; b.
mov edx,[var4+4]   ; c.
movsx edx,var1     ; d.
```

**Answer:**
- **(a)** EDX = 00000001h
- **(b)** EDX = 00001000h (zero-extended from var2[0])
- **(c)** EDX = 00000002h (var4[1])
- **(d)** EDX = FFFFFFFCh (sign-extended from var1[0] = -4 = FCh)
