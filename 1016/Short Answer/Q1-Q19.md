## 4.9.1 Short Answer

### 1. What will be the value in EDX after each of the lines marked (a) and (b) execute?
```asm
.data
one WORD 8002h
two WORD 4321h
.code
mov edx,21348041h
movsx edx,one  ; (a)
movsx edx,two  ; (b)
```

**답:**
- **(a)** EDX = FFFF8002h (8002h에서 부호 확장, MSB=1이므로 음수)
- **(b)** EDX = 00004321h (4321h에서 부호 확장, MSB=0이므로 양수)

---

### 2. What will be the value in EAX after the following lines execute?
```asm
mov eax,1002FFFFh
inc ax
```

**답:**
- EAX = 10020000h
- 설명: AX = FFFFh, INC 후: AX = 0000h, 상위 워드(1002h)는 변경 안 됨

---

### 3. What will be the value in EAX after the following lines execute?
```asm
mov eax,30020000h
dec ax
```

**답:**
- EAX = 3002FFFFh
- 설명: AX = 0000h, DEC 후: AX = FFFFh, 상위 워드(3002h)는 변경 안 됨

---

### 4. What will be the value in EAX after the following lines execute?
```asm
mov eax,1002FFFFh
neg ax
```

**답:**
- EAX = 10020001h
- 설명: AX = FFFFh, NEG(FFFFh) = 0001h, 상위 워드는 변경 안 됨

---

### 5. What will be the value of the Parity flag after the following lines execute?
```asm
mov al,1
add al,3
```

**답:**
- Parity Flag = 0 (홀수 패리티)
- 설명: AL = 1 + 3 = 4 = 00000100b (1비트가 1개 = 홀수 패리티, PF=0)

---

### 6. What will be the value of EAX and the Sign flag after the following lines execute?
```asm
mov eax,5
sub eax,6
```

**답:**
- EAX = FFFFFFFFh (2의 보수로 -1)
- Sign Flag = 1 (MSB가 1이므로 음수 결과)

---

### 7. In the following code, the value in AL is intended to be a signed byte. Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range.
```asm
mov al,-1
add al,130
```

**답:**
- AL = -1 (FFh) + 130 (82h) = 129 (81h)
- 오버플로우 플래그는 1로 설정됨
- 설명: 부호있는 해석에서 -1 + 130 = 129인데, 이는 부호있는 바이트 범위(-128 ~ +127)를 초과합니다. OF=1은 부호있는 산술에서 결과가 유효하지 않음을 나타내어 오버플로우 감지에 도움이 됩니다.

---

### 8. What value will RAX contain after the following instruction executes?
```asm
mov rax,44445555h
```

**답:**
- RAX = 0000000044445555h
- 설명: 상위 32비트는 0으로 확장됨

---

### 9. What value will RAX contain after the following instructions execute?
```asm
.data
dwordVal DWORD 84326732h
.code
mov rax,0FFFFFFFF00000000h
mov rax,dwordVal
```

**답:**
- RAX = 0000000084326732h
- 설명: DWORD를 RAX로 이동하면 상위 32비트가 0으로 확장됨

---

### 10. What value will EAX contain after the following instructions execute?
```asm
.data
dVal DWORD 12345678h
.code
mov ax,3
mov WORD PTR dVal+2,ax
mov eax,dVal
```

**답:**
- EAX = 00035678h
- 설명: dVal 초기값 = 12345678h (바이트: 78 56 34 12), 상위 워드(바이트 2-3)가 0003h로 변경, 결과 = 00035678h

---

### 11. What will EAX contain after the following instructions execute?
```asm
.data
dVal DWORD ?
.code
mov dVal,12345678h
mov ax,WORD PTR dVal+2
add ax,3
mov WORD PTR dVal,ax
mov eax,dVal
```

**답:**
- EAX = 12341237h
- 설명: 
  - dVal = 12345678h
  - AX = 상위 워드 = 1234h
  - AX = 1234h + 3 = 1237h
  - dVal의 하위 워드 = 1237h
  - 결과 = 12341237h

---

### 12. (Yes/No): Is it possible to set the Overflow flag if you add a positive integer to a negative integer?

**답:**
- **No**
- 설명: 오버플로우는 두 양수를 더해서 음수가 나오거나, 두 음수를 더해서 양수가 나올 때만 발생합니다. 양수와 음수를 더하면 부호있는 오버플로우가 발생할 수 없습니다.

---

### 13. (Yes/No): Will the Overflow flag be set if you add a negative integer to a negative integer and produce a positive result?

**답:**
- **Yes**
- 설명: 두 음수를 더해서 양수 결과가 나오면 부호있는 오버플로우를 나타냅니다(결과가 음수 범위를 초과함).

---

### 14. (Yes/No): Is it possible for the NEG instruction to set the Overflow flag?

**답:**
- **Yes**
- 설명: NEG 80h (8비트) 또는 NEG 8000h (16비트)는 오버플로우 플래그를 설정합니다. 가장 작은 음수는 2의 보수에서 양수 대응값이 없기 때문입니다.

---

### 15. (Yes/No): Is it possible for both the Sign and Zero flags to be set at the same time?

**답:**
- **No**
- 설명: Zero 플래그는 결과가 0일 때 설정됩니다(MSB 포함 모든 비트가 0). Sign 플래그는 MSB가 1일 때 설정됩니다. 이 두 조건은 상호 배타적입니다.

---

## Variable Definitions for Questions 16-19
```asm
.data
var1 SBYTE -4,-2,3,1
var2 WORD 1000h,2000h,3000h,4000h
var3 SWORD -16,-42
var4 DWORD 1,2,3,4,5
```

### 16. For each of the following statements, state whether or not the instruction is valid:

**답:**
- a. `mov ax,var1` - **유효하지 않음** (크기 불일치: AX는 16비트, var1은 8비트)
- b. `mov ax,var2` - **유효함**
- c. `mov eax,var3` - **유효하지 않음** (크기 불일치: EAX는 32비트, var3는 16비트)
- d. `mov var2,var3` - **유효하지 않음** (메모리에서 메모리로 직접 이동 불가)
- e. `movzx ax,var2` - **유효하지 않음** (목적지가 소스보다 커야 함)
- f. `movzx var2,al` - **유효하지 않음** (목적지는 레지스터여야 함)
- g. `mov ds,ax` - **유효함**
- h. `mov ds,1000h` - **유효하지 않음** (세그먼트 레지스터에 즉시값 직접 이동 불가)

---

### 17. What will be the hexadecimal value of the destination operand after each of the following instructions execute in sequence?
```asm
mov al,var1      ; a.
mov ah,[var1+3]  ; b.
```

**답:**
- **(a)** AL = FCh (var1[0] = -4를 2의 보수로)
- **(b)** AH = 01h (var1[3] = 1), 따라서 AX = 01FCh

---

### 18. What will be the value of the destination operand after each of the following instructions execute in sequence?
```asm
mov ax,var2      ; a.
mov ax,[var2+4]  ; b.
mov ax,var3      ; c.
mov ax,[var3-2]  ; d.
```

**답:**
- **(a)** AX = 1000h
- **(b)** AX = 3000h (var2[2], 오프셋 +4바이트)
- **(c)** AX = FFF0h (2의 보수로 -16)
- **(d)** AX = 4000h (var3 앞 2바이트 접근, var2의 마지막 요소)

---

### 19. What will be the value of the destination operand after each of the following instructions execute in sequence?
```asm
mov edx,var4       ; a.
movzx edx,var2     ; b.
mov edx,[var4+4]   ; c.
movsx edx,var1     ; d.
```

**답:**
- **(a)** EDX = 00000001h
- **(b)** EDX = 00001000h (var2[0]에서 0 확장)
- **(c)** EDX = 00000002h (var4[1])
- **(d)** EDX = FFFFFFFCh (var1[0] = -4 = FCh에서 부호 확장)
