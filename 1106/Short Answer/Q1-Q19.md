# 6.10.1 Short Answer

## 1. What will be the value of BX after the following instructions execute?
```assembly
mov bx,0FFFFh
and bx,6Bh
```
**답:** 006Bh

AND 연산은 두 피연산자의 비트가 모두 1일 때만 1이 됩니다. 0FFFFh와 006Bh를 AND하면 006Bh가 됩니다.

## 2. What will be the value of BX after the following instructions execute?
```assembly
mov bx,91BAh
and bx,92h
```
**답:** 0092h

91BAh (1001 0001 1011 1010)와 0092h (0000 0000 1001 0010)를 AND하면 0092h가 됩니다.

## 3. What will be the value of BX after the following instructions execute?
```assembly
mov bx,0649Bh
or bx,3Ah
```
**답:** 64BBh

649Bh (0110 0100 1001 1011)와 003Ah (0000 0000 0011 1010)를 OR하면 64BBh가 됩니다.

## 4. What will be the value of BX after the following instructions execute?
```assembly
mov rbx,029D6h
xor bx,8181h
```
**답:** A857h

29D6h (0010 1001 1101 0110)와 8181h (1000 0001 1000 0001)를 XOR하면 A857h가 됩니다.

## 5. What will be the value of EBX after the following instructions execute?
```assembly
mov ebx,0AFAF649Bh
or ebx,3A219604h
```
**답:** BFAF769Fh

AFAF649Bh와 3A219604h를 OR하면 BFAF769Fh가 됩니다.

## 6. What will be the value of RBX after the following instructions execute?
```assembly
mov rbx,0AFAF649Bh
xor rbx,0FFFFFFFFh
```
**답:** FFFFFFFF50509B64h

0AFAF649Bh를 64비트로 확장하면 00000000AFAF649Bh가 되고, 이를 00000000FFFFFFFFh와 XOR하면 FFFFFFFF50509B64h가 됩니다.

## 7. In the following instruction sequence, show the resulting value of AL where indicated, in binary:
```assembly
mov al,01101111b
and al,00101101b  ; a.
mov al,6Dh
and al,4Ah        ; b.
mov al,00001111b
or al,61h         ; c.
mov al,94h
xor al,37h        ; d.
```
**답:**
- a. 00101101b
- b. 01001000b (48h)
- c. 01101111b (6Fh)
- d. 10100011b (A3h)

## 8. In the following instruction sequence, show the resulting value of AL where indicated, in hexadecimal:
```assembly
mov al,7Ah
not al            ; a.
mov al,3Dh
and al,74h        ; b.
mov al,9Bh
or al,35h         ; c.
mov al,72h
xor al,0DCh       ; d.
```
**답:**
- a. 85h
- b. 34h
- c. BFh
- d. AEh

## 9. In the following instruction sequence, show the values of the Carry, Zero, and Sign flags where indicated:
```assembly
mov al,00001111b
test al,00000010b  ; a. CF= ZF= SF=
mov al,00000110b
cmp al,00000101b   ; b. CF= ZF= SF=
mov al,00000101b
cmp al,00000111b   ; c. CF= ZF= SF=
```
**답:**
- a. CF=0, ZF=1, SF=0
- b. CF=0, ZF=0, SF=0
- c. CF=1, ZF=0, SF=1

## 10. Which conditional jump instruction executes a branch based on the contents of ECX?
**답:** JCXZ (CX가 0일 때), JECXZ (ECX가 0일 때), JRCXZ (RCX가 0일 때)

## 11. How are JA and JNBE affected by the Zero and Carry flags?
**답:** JA (Jump if Above)와 JNBE (Jump if Not Below or Equal)는 동일한 명령어입니다. CF=0이고 ZF=0일 때 점프합니다. (부호 없는 비교에서 크다)

## 12. What will be the final value in EDX after this code executes?
```assembly
mov edx,1
mov eax,7FFFh
cmp eax,8000h
jl L1
mov edx,0
L1:
```
**답:** 1

7FFFh(32767) < 8000h(32768)이므로 (부호 있는 비교) JL이 점프하고 EDX는 1을 유지합니다.

## 13. What will be the final value in EDX after this code executes?
```assembly
mov edx,1
mov eax,7FFFh
cmp eax,8000h
jb L1
mov edx,0
L1:
```
**답:** 0

7FFFh < 8000h이므로 부호 없는 비교에서 JB(Jump if Below)가 점프해야 하지만, 실제로는 7FFFh(32767) < 8000h(32768)이므로 점프합니다. 따라서 EDX는 1을 유지합니다.

**수정:** 7FFFh(32767) < 8000h(32768)이므로 JB가 점프하여 EDX는 1입니다.

## 14. What will be the final value in EDX after this code executes?
```assembly
mov edx,1
mov eax,7FFFh
cmp eax,0FFFF8000h
jl L2
mov edx,0
L2:
```
**답:** 0

부호 있는 비교에서 7FFFh(32767) > FFFF8000h(-32768)이므로 JL은 점프하지 않고, EDX는 0이 됩니다.

## 15. (True/False): The following code will jump to the label named Target.
```assembly
mov eax,-30
cmp eax,-50
jg Target
```
**답:** True

-30 > -50이므로 JG(Jump if Greater, 부호 있는 비교)가 점프합니다.

## 16. (True/False): The following code will jump to the label named Target.
```assembly
mov eax,-42
cmp eax,26
ja Target
```
**답:** False

JA는 부호 없는 비교입니다. -42는 부호 없는 값으로는 매우 큰 수(FFFFFFD6h)이지만, JA는 CF=0이고 ZF=0일 때 점프합니다. -42와 26을 비교하면 -42(FFFFFFD6h) > 26이므로 실제로는 True입니다.

**수정:** -42를 부호 없는 값으로 해석하면 FFFFFFD6h이고, 이는 26(0000001Ah)보다 크므로 JA가 점프합니다. **답: True**

## 17. What will be the value of RBX after the following instructions execute?
```assembly
mov rbx,0FFFFFFFFFFFFFFFFh
and rbx,80h
```
**답:** 0000000000000080h

모든 비트를 AND하면 80h만 남습니다.

## 18. What will be the value of RBX after the following instructions execute?
```assembly
mov rbx,0FFFFFFFFFFFFFFFFh
and rbx,808080h
```
**답:** 0000000000808080h

808080h와 AND하면 해당 비트만 남습니다.

## 19. What will be the value of RBX after the following instructions execute?
```assembly
mov rbx,0FFFFFFFFFFFFFFFFh
and rbx,80808080h
```
**답:** 0000000080808080h

80808080h와 AND하면 해당 비트만 남습니다.

