# Short Answer

## 1. Which statements belong in a procedure's epilogue when the procedure has stack parameters and local variables?

**답:** 프로시저의 에필로그에는 다음 문장들이 포함됩니다:
- `mov esp, ebp` (스택 포인터를 베이스 포인터로 복원하여 지역 변수 해제)
- `pop ebp` (호출자의 베이스 포인터 복원)
- `ret n` (반환 주소로 점프하고, STDCALL의 경우 스택 매개변수 정리)

---

## 2. When a C function returns a 32-bit integer, where is the return value stored?

**답:** `EAX` 레지스터에 저장됩니다.

---

## 3. How does a program using the STDCALL calling convention clean up the stack after a procedure call?

**답:** STDCALL 호출 규약에서는 **피호출자(callee)**가 스택을 정리합니다. `RET n` 명령어를 사용하여 반환과 동시에 스택에서 n바이트의 매개변수를 제거합니다.

---

## 4. How is the LEA instruction more powerful than the OFFSET operator?

**답:** 
- `OFFSET`은 **컴파일 시간**에 결정되는 상수 주소만 계산할 수 있습니다.
- `LEA`는 **실행 시간**에 복잡한 주소 계산(베이스 + 인덱스 × 스케일 + 변위)이 가능하며, 레지스터 기반 주소와 지역 변수의 주소도 계산할 수 있습니다.

---

## 5. In the C++ example shown in Section 8.2.3, how much stack space is used by a variable of type int?

**답:** **4바이트** (32비트 시스템 기준)

---

## 6. What advantages might the C calling convention have over the STDCALL calling convention?

**답:**
- **가변 인자 함수**(예: `printf`)를 지원할 수 있습니다.
- 호출자가 스택을 정리하므로 매개변수 개수가 가변적인 함수 구현이 가능합니다.
- 디버깅 시 스택 추적이 더 용이합니다.

---

## 7. (True/False): When using the PROC directive, all parameters must be listed on the same line.

**답:** **False (거짓)**

매개변수를 여러 줄에 걸쳐 나열할 수 있으며, 쉼표와 줄 연속 문자(`\`)를 사용하거나 별도의 줄에 작성할 수 있습니다.

---

## 8. (True/False): If you pass a variable containing the offset of an array of bytes to a procedure that expects a pointer to an array of words, the assembler will flag this as an error.

**답:** **False (거짓)**

어셈블러는 포인터의 타입 호환성을 검사하지 않습니다. 이는 프로그래머가 주의해야 할 사항입니다.

---

## 9. (True/False): If you pass an immediate value to a procedure that expects a reference parameter, you can generate a general-protection fault.

**답:** **True (참)**

즉시값(상수)을 참조 매개변수로 전달하면, 프로시저가 해당 값을 메모리 주소로 해석하여 잘못된 메모리 접근을 시도하게 되어 일반 보호 오류(GPF)가 발생할 수 있습니다.

